skip main content browser longer supported upgrade microsoft edge take advantage latest features security updates technical support download microsoft edge info internet explorer microsoft edge table contents exit focus mode read english save table contents read english save add plan edit share via facebook xcom linkedin email print table contents reliability design principles article contributors feedback article outages malfunctions serious concerns workloads reliable workload must survive events continue consistently provide intended functionality must resilient detect withstand recover failures within acceptable time period must also available users access workload promised time period promised quality level realistic assume failures wont occur especially workload built run distributed systems components might fail others continue operate point user experience might affected compromises business goals workload architectures reliability assurances application code infrastructure operations design choices shouldnt change intent thats specified business requirements changes considered significant tradeoffs design principles intended provide guidance aspects reliability consider throughout development lifecycle start recommended approaches justify benefits set requirements set strategy drive actions using reliability checklist dont apply principles design workload likely wont prepared anticipate handle problems production outcome might service disruptions lead financial loss case critical workloads failing apply principles could jeopardize safety design business requirements gather business requirements focus intended utility workload requirements must cover user experience data workflows characteristics unique workload outcome requirements process must clearly state expectations goals must achievable negotiated team given specified investment must documented drive technological choices implementations operations approach benefit quantify success setting targets indicators individual components system flows system whole targets make user flows reliable metrics quantify expectations enable understand complexities determine whether downstream costs complexities within investment limit target values indicate ideal state use values test thresholds help detect deviations state long takes return target state compliance requirements must also predictable outcomes inscope flows prioritizing flows bring attention areas sensitive understand platform commitments consider limits quotas regions capacity constraints services servicelevel agreements slas vary service services features covered equally services features available regions subscription resource limits per region good understanding coverage limits help detect drift build resiliency recovery mechanisms determine dependencies effect resiliency keeping track dependent infrastructure services apis functions developed teams third parties helps determine whether workload operate absence dependencies also helps understand cascading failures improve downstream operations developers implement resilient design patterns handle potential failures use external services might susceptible failures design resilience workload must continue operate full reduced functionality expect component malfunctions platform outages performance degradations limited resource availability faults occur build resiliency system faulttolerant degrade gracefully approach benefit distinguish components critical path function degraded state components workload need equally reliable determining criticality helps design according criticality component wont overengineer resiliency components could slightly deteriorate user experience opposed components cause endtoend problems fail design efficient allocating resources critical components also implement fault isolation strategies noncritical component fails enters degraded state isolated prevent cascading failures identify potential failure points system especially critical components determine effect user flows analyze failure cases blast radius intensity fault full partial outage analysis influences design error handling capabilities component level build selfpreservation capabilities using design patterns correctly modularizing design isolate faults system able prevent problem affecting downstream components system able mitigate transient permanent failures performance bottlenecks problems might affect reliability youll also able minimize blast radius add capability scale critical components application infrastructure considering capacity constraints services supported regions workload able handle variable capacity spikes fluctuations capability crucial theres unexpected load system like surge valid usage workload designed scale multiple regions even overcome potential temporary resource capacity constraints issues impacting single region build redundancy layers resiliency various application tiers aim redundancy physical utilities immediate data replication also aim redundancy functional layer covers services operations personnel redundancy helps minimize single points failure example there’s component zonal regional outage redundant deployment activeactive activepassive allows meet uptime targets adding intermediaries prevents direct dependency components improves buffering benefits harden resiliency system overprovision immediately mitigate individual failure redundant instances buffer runaway resource consumption higher investment overprovisioning increases resiliency system continue operate full utility active failure even scaling operations start remediate failure likewise reduce risk unexpected runaway resource consumption claiming planned buffer gaining critical triage time system faults aggressive scaling occurs design recovery workload must able anticipate recover failures magnitudes minimal disruption user experience business objectives even highly resilient systems need disaster preparedness approaches architecture design workload operations data layer strategies repair workload state case corruption approach benefit structured tested documented recovery plans aligned negotiated recovery targets plans must cover components addition system whole welldefined process leads quick recovery prevent negative impact finances reputation business conducting regular recovery drills tests process recovering system components data failover failback steps avoid confusion time data integrity key measures success ensure repair data stateful components within recovery targets backups essential getting system back working state using trusted recovery point like lastknown good state immutable transactionally consistent backups ensure data cant altered restored data isnt corrupted implement automated selfhealing capabilities design automation reduces risks external factors like human intervention shortens breakfix cycle replace stateless components immutable ephemeral units building ephemeral units spin destroy demand provides repeatability consistency use sidebyside deployment models make transition new units incremental minimizing disruptions design operations shift left operations anticipate failure conditions test failures early often development lifecycle determine impact performance reliability sake root cause analysis postmortems need shared visibility across teams dependency status ongoing failures insights diagnostics alerts observable systems fundamental effective incident management continuous improvement approach benefit build observable systems correlate telemetry monitoring diagnostics crucial operations something fails need know failed failed failed observability component level fundamental aggregated observability components correlated user flows provides holistic view health status data required enable sitereliability engineers prioritize efforts remediation predict potential malfunctions anomalous behavior make active reliability failures visible using prioritized actionable alerts invest reliable processes infrastructure leads quicker triage site reliability engineers notified immediately mitigate ongoing live site incidents proactively mitigate potential failures identified predictive alerts become live incidents simulate failures run tests production preproduction environments beneficial experience failures production set realistic expectations recovery allows make design choices gracefully respond failures also enables test thresholds set business metrics build components automation mind automate much automation minimizes potential human error bringing consistency testing deployment operations factor routine operations impact stability system workload might subject ongoing operations like application revisions security compliance audits component upgrades backup processes scrutinizing changes ensures stability system continuously learn incidents production based incidents determine impact oversights design operations might go unnoticed preproduction ultimately youll able drive improvements based reallife incidents keep simple avoid overengineering architecture design application code operations often remove rather add leads reliable solutions simplicity reduces surface area control minimizing inefficiencies potential misconfigurations unexpected interactions hand oversimplification introduce single points failure maintain balanced approach approach benefit add components architecture help achieve target business values keep critical path lean designing business requirements lead straightforward solution thats easy implement manage avoid many critical components one significant point failure establish standards code implementation deployment processes document identify opportunities enforce standards using automated validations standards provide consistency minimize human errors approaches like standard naming conventions code style guides help maintain quality make assets easy identify troubleshooting evaluate whether theoretical approaches translate pragmatic design applies use cases application code thats granular lead unnecessary interdependence extra operations difficult maintenance develop enough code youll able prevent problems result inefficient implementations like unexpected resource consumption user dataflow failures code bugs conversely reliability problems lead code reviews ensure code resilient enough handle problems take advantage platformprovided features prebuilt assets help effectively meet business targets approach minimizes development time also enables rely tried tested practices used similar workloads next steps reliability checklist feedback page helpful yes additional resources privacy choices theme light dark high contrast previous versions blog contribute privacy terms use trademarks © microsoft additional resources article privacy choices theme light dark high contrast previous versions blog contribute privacy terms use trademarks © microsoft